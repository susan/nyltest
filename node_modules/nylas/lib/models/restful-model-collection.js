"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _async = _interopRequireDefault(require("async"));

var _isFunction = _interopRequireDefault(require("lodash/isFunction"));

var _message = _interopRequireDefault(require("./message"));

var _thread = _interopRequireDefault(require("./thread"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var REQUEST_CHUNK_SIZE = 100;

var RestfulModelCollection =
/*#__PURE__*/
function () {
  function RestfulModelCollection(modelClass, connection) {
    _classCallCheck(this, RestfulModelCollection);

    this.modelClass = modelClass;
    this.connection = connection;

    if (!(this.connection instanceof require('../nylas-connection'))) {
      throw new Error('Connection object not provided');
    }

    if (!this.modelClass) {
      throw new Error('Model class not provided');
    }
  }

  _createClass(RestfulModelCollection, [{
    key: "forEach",
    value: function forEach() {
      var _this = this;

      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var eachCallback = arguments.length > 1 ? arguments[1] : undefined;
      var completeCallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (params.view == 'count') {
        var err = new Error('forEach() cannot be called with the count view');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      var offset = 0;
      var finished = false;
      return _async.default.until(function () {
        return finished;
      }, function (callback) {
        return _this._getItems(params, offset, REQUEST_CHUNK_SIZE).then(function (items) {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = items[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var item = _step.value;
              eachCallback(item);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          offset += items.length;
          finished = items.length < REQUEST_CHUNK_SIZE;
          return callback();
        });
      }, function (err) {
        if (completeCallback) {
          return completeCallback(err);
        }
      });
    }
  }, {
    key: "count",
    value: function count() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      return this.connection.request({
        method: 'GET',
        path: this.path(),
        qs: _objectSpread({
          view: 'count'
        }, params)
      }).then(function (json) {
        if (callback) {
          callback(null, json.count);
        }

        return Promise.resolve(json.count);
      }).catch(function (err) {
        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      });
    }
  }, {
    key: "first",
    value: function first() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (params.view == 'count') {
        var err = new Error('first() cannot be called with the count view');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      return this._getItems(params, 0, 1).then(function (items) {
        if (callback) {
          callback(null, items[0]);
        }

        return Promise.resolve(items[0]);
      }).catch(function (err) {
        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      });
    }
  }, {
    key: "list",
    value: function list() {
      var params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

      if (params.view == 'count') {
        var err = new Error('list() cannot be called with the count view');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      var limit = params.limit || Infinity;
      var offset = params.offset;
      return this._range({
        params: params,
        offset: offset,
        limit: limit,
        callback: callback
      });
    }
  }, {
    key: "find",
    value: function find(id) {
      var callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
      var params = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!id) {
        var err = new Error('find() must be called with an item id');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      if (params.view == 'count' || params.view == 'ids') {
        var _err = new Error('find() cannot be called with the count or ids view');

        if (callback) {
          callback(_err);
        }

        return Promise.reject(_err);
      }

      return this._getModel(id, params).then(function (model) {
        if (callback) {
          callback(null, model);
        }

        return Promise.resolve(model);
      }).catch(function (err) {
        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      });
    }
  }, {
    key: "search",
    value: function search(query) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (this.modelClass != _message.default && this.modelClass != _thread.default) {
        var err = new Error('search() can only be called for messages and threads');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      if (!query) {
        var _err2 = new Error('search() requires a query string');

        if (callback) {
          callback(_err2);
        }

        return Promise.reject(_err2);
      }

      params.q = query;
      var limit = params.limit || 40;
      var offset = params.offset;
      var path = "".concat(this.path(), "/search");
      return this._range({
        params: params,
        offset: offset,
        limit: limit,
        path: path
      });
    }
  }, {
    key: "delete",
    value: function _delete(itemOrId) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      var callback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

      if (!itemOrId) {
        var err = new Error('delete() requires an item or an id');

        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      }

      var id = itemOrId.id ? itemOrId.id : itemOrId;

      if ((0, _isFunction.default)(params)) {
        callback = params;
        params = {};
      }

      return this.connection.request({
        method: 'DELETE',
        qs: params,
        path: "".concat(this.path(), "/").concat(id)
      }).then(function () {
        if (callback) {
          callback(null);
        }

        return Promise.resolve();
      }).catch(function (err) {
        if (callback) {
          callback(err);
        }

        return Promise.reject(err);
      });
    }
  }, {
    key: "build",
    value: function build(args) {
      var model = new this.modelClass(this.connection);

      for (var key in args) {
        var val = args[key];
        model[key] = val;
      }

      return model;
    }
  }, {
    key: "path",
    value: function path() {
      return "/".concat(this.modelClass.collectionName);
    }
  }, {
    key: "_range",
    value: function _range(_ref) {
      var _this2 = this;

      var _ref$params = _ref.params,
          params = _ref$params === void 0 ? {} : _ref$params,
          _ref$offset = _ref.offset,
          offset = _ref$offset === void 0 ? 0 : _ref$offset,
          _ref$limit = _ref.limit,
          limit = _ref$limit === void 0 ? 100 : _ref$limit,
          _ref$callback = _ref.callback,
          callback = _ref$callback === void 0 ? null : _ref$callback,
          _ref$path = _ref.path,
          path = _ref$path === void 0 ? null : _ref$path;
      return new Promise(function (resolve, reject) {
        var accumulated = [];
        var finished = false;
        return _async.default.until(function () {
          return finished;
        }, function (chunkCallback) {
          var chunkOffset = offset + accumulated.length;
          var chunkLimit = Math.min(REQUEST_CHUNK_SIZE, limit - accumulated.length);
          return _this2._getItems(params, chunkOffset, chunkLimit, path).then(function (items) {
            accumulated = accumulated.concat(items);
            finished = items.length < REQUEST_CHUNK_SIZE || accumulated.length >= limit;
            return chunkCallback();
          }).catch(function (err) {
            return reject(err);
          });
        }, function (err) {
          if (err) {
            if (callback) {
              callback(err);
            }

            return reject(err);
          } else {
            if (callback) {
              callback(null, accumulated);
            }

            return resolve(accumulated);
          }
        });
      });
    }
  }, {
    key: "_getItems",
    value: function _getItems(params, offset, limit, path) {
      // Items can be either models or ids
      if (!path) {
        path = this.path();
      }

      if (params.view == 'ids') {
        return this.connection.request({
          method: 'GET',
          path: path,
          qs: _objectSpread({}, params, {
            offset: offset,
            limit: limit
          })
        });
      }

      return this._getModelCollection(params, offset, limit, path);
    }
  }, {
    key: "_createModel",
    value: function _createModel(json) {
      return new this.modelClass(this.connection, json);
    }
  }, {
    key: "_getModel",
    value: function _getModel(id) {
      var _this3 = this;

      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this.connection.request({
        method: 'GET',
        path: "".concat(this.path(), "/").concat(id),
        qs: params
      }).then(function (json) {
        var model = _this3._createModel(json);

        return Promise.resolve(model);
      });
    }
  }, {
    key: "_getModelCollection",
    value: function _getModelCollection(params, offset, limit, path) {
      var _this4 = this;

      return this.connection.request({
        method: 'GET',
        path: path,
        qs: _objectSpread({}, params, {
          offset: offset,
          limit: limit
        })
      }).then(function (jsonArray) {
        var models = jsonArray.map(function (json) {
          return _this4._createModel(json);
        });
        return Promise.resolve(models);
      });
    }
  }]);

  return RestfulModelCollection;
}();

exports.default = RestfulModelCollection;