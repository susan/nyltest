"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _omit = _interopRequireDefault(require("lodash/omit"));

var _backoff = _interopRequireDefault(require("backoff"));

var _JSONStream = _interopRequireDefault(require("JSONStream"));

var _request = _interopRequireDefault(require("request"));

var _events = require("events");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var Delta =
/*#__PURE__*/
function () {
  function Delta(connection) {
    _classCallCheck(this, Delta);

    this.connection = connection;

    if (!(this.connection instanceof require('../nylas-connection'))) {
      throw new Error('Connection object not provided');
    }
  }

  _createClass(Delta, [{
    key: "latestCursor",
    value: function latestCursor(callback) {
      var reqOpts = {
        method: 'POST',
        path: '/delta/latest_cursor'
      };
      return this.connection.request(reqOpts).then(function (response) {
        var cursor = response.cursor;

        if (callback) {
          callback(null, cursor);
        }

        return Promise.resolve(cursor);
      }).catch(function (err) {
        if (callback) {
          callback(err, null);
        }

        return Promise.reject(err);
      });
    }
  }, {
    key: "startStream",
    value: function startStream(cursor) {
      var params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      return this._startStream(_request.default, cursor, params);
    }
  }, {
    key: "_startStream",
    value: function _startStream(createRequest, cursor, params) {
      var stream = new DeltaStream(createRequest, this.connection, cursor, params);
      stream.open();
      return stream;
    }
  }]);

  return Delta;
}();

exports.default = Delta;
Delta.streamingTimeoutMs = 15000;
/*
A connection to the Nylas delta streaming API.

Emits the following events:
- `response` when the connection is established, with one argument, a `http.IncomingMessage`
- `delta` for each delta received
- `error` when an error occurs in the connection
- `info` when the connection status changes
*/

var DeltaStream =
/*#__PURE__*/
function (_EventEmitter) {
  _inherits(DeltaStream, _EventEmitter);

  // @param {function} createRequest function to create a request; only present for testability
  // @param {string} cursor Nylas delta API cursor
  // @param {Object} params object contianing query string params to be passed to  the request
  // @param {Array<string>} params.excludeTypes object types to not return deltas for (e.g., {excludeTypes: ['thread']})
  // @param {Array<string>} params.includeTypes object types to exclusively return deltas for (e.g., {includeTypes: ['thread']})
  // @param {boolean} params.expanded boolean to specify wether to request the expanded view
  function DeltaStream(createRequest, connection, cursor) {
    var _this;

    var params = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, DeltaStream);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(DeltaStream).call(this, createRequest, connection, cursor, params));
    _this.createRequest = createRequest;
    _this.connection = connection;
    _this.cursor = cursor;
    _this.params = params;

    if (!(_this.connection instanceof require('../nylas-connection'))) {
      throw new Error('Connection object not provided');
    }

    _this.restartBackoff = _backoff.default.exponential({
      randomisationFactor: 0.5,
      initialDelay: 250,
      maxDelay: 30000,
      factor: 4
    });

    _this.restartBackoff.failAfter(DeltaStream.MAX_RESTART_RETRIES);

    _this.restartBackoff.on('backoff', _this._restartConnection.bind(_assertThisInitialized(_this))).on('fail', function () {
      return _this.emit('error', "Nylas DeltaStream failed to reconnect after ".concat(DeltaStream.MAX_RESTART_RETRIES, " retries."));
    });

    return _this;
  }

  _createClass(DeltaStream, [{
    key: "close",
    value: function close() {
      clearTimeout(this.timeoutId);
      delete this.timeoutId;
      this.restartBackoff.reset();

      if (this.request) {
        this.request.abort();
      }

      delete this.request;
    }
  }, {
    key: "open",
    value: function open() {
      var _this2 = this;

      this.close();
      var path = '/delta/streaming';
      var excludeTypes = this.params.excludeTypes != null ? this.params.excludeTypes : [];
      var includeTypes = this.params.includeTypes != null ? this.params.includeTypes : [];

      var queryObj = _objectSpread({}, (0, _omit.default)(this.params, ['excludeTypes', 'includeTypes']), {
        cursor: this.cursor
      });

      if (excludeTypes.length > 0) {
        queryObj.exclude_types = excludeTypes.join(',');
      }

      if (includeTypes.length > 0) {
        queryObj.include_types = includeTypes.join(',');
      }

      var reqOpts = this.connection.requestOptions({
        method: 'GET',
        path: path,
        qs: queryObj
      });
      return this.request = this.createRequest(reqOpts).on('response', function (response) {
        if (response.statusCode !== 200) {
          response.on('data', function (data) {
            var err = data;

            try {
              err = JSON.parse(err);
            } catch (e) {} // Do nothing, keep err as string.


            return _this2._onError(err);
          });
          return;
        } // Successfully established connection


        _this2.emit('response', response);

        _this2._onDataReceived();

        return response.on('data', _this2._onDataReceived.bind(_this2)) // Each data block received may not be a complete JSON object. Pipe through
        // JSONStream.parse(), which handles converting data blocks to JSON objects.
        .pipe(_JSONStream.default.parse()).on('data', function (obj) {
          if (obj.cursor) {
            _this2.cursor = obj.cursor;
          }

          return _this2.emit('delta', obj);
        });
      }).on('error', this._onError.bind(this));
    }
  }, {
    key: "_onDataReceived",
    value: function _onDataReceived(data) {
      // Nylas sends a newline heartbeat in the raw data stream once every 5 seconds.
      // Automatically restart the connection if we haven't gotten any data in
      // Delta.streamingTimeoutMs. The connection will restart with the last
      // received cursor.
      clearTimeout(this.timeoutId);
      this.restartBackoff.reset();
      return this.timeoutId = setTimeout(this.restartBackoff.backoff.bind(this.restartBackoff), Delta.streamingTimeoutMs);
    }
  }, {
    key: "_onError",
    value: function _onError(err) {
      this.emit('error', err);
      return this.restartBackoff.reset();
    }
  }, {
    key: "_restartConnection",
    value: function _restartConnection(n) {
      this.emit('info', "Restarting Nylas DeltaStream connection (attempt ".concat(n + 1, "): ").concat(this.request != null ? this.request.href : undefined));
      this.close();
      return this.open();
    }
  }]);

  return DeltaStream;
}(_events.EventEmitter); // Max number of times to retry a connection if we receive no data heartbeats
// from the Nylas server.


DeltaStream.MAX_RESTART_RETRIES = 5;